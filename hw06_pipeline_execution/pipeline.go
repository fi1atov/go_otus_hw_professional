package hw06pipelineexecution

import "sync"

// конвеер обработки данных

type (
	In  = <-chan interface{} // канал только на чтение
	Out = In                 // еще один канал только на чтение
	Bi  = chan interface{}   // канал на чтение и на запись
)

// тип функции, которая принимает канал in на чтение
// и возвращает канал out тоже на чтение.
// в ExecutePipeline мы ожидаем принять слайс функций только с такой сигнатурой.
type Stage func(in In) (out Out)

// функция принимает:
// in In - канал на чтение, из которого поступают входные данные
// done In - канал на чтение, сигнализирующий о завершении работы.
// Если из этого канала можно прочитать значение, это означает,
// что конвейер должен завершить работу
// stages ...Stage - переменное количество аргументов типа Stage,
// представляющих различные стадии обработки данных
// Out - возвращается канал Out из которого можно прочитать результат.
func ExecutePipeline(in In, done In, stages ...Stage) Out {
	wg := sync.WaitGroup{}
	outCh := in
	// перебираем слайс функций
	for _, stage := range stages {
		outCh = func(in In) (out Out) {
			bindCh := make(Bi) // создание каналаx через make, чтобы не было nil
			// это промежуточный канал который контролируется горутиной,
			// передающей данные с учетом возможного завершения работы через канал done.
			wg.Add(1)

			go func() { // запуск горутины внутри анонимной функции
				defer wg.Done()
				defer close(bindCh) // закрыть канал по завершении работы горутины

				for { // В бесконечном цикле:
					select {
					case <-done: // Если сигнал завершения получен, горутина завершает работу.
						// log.Println("graceful shutdown")
						return
					case v, ok := <-in: // Читает данные из входного канала in. Если канал in закрыт, горутина завершит работу.
						if !ok { // Если входной канал закрыт, завершить работу горутины
							return
						}
						select {
						case <-done: // Если поступил сигнал завершения, просто выходим
						case bindCh <- v: // Перекладываем прочитанные данные в связующий канал bindCh
							// log.Println("перекладываем значение в связующий канал")
						}
					}
				}
			}()
			// log.Println("Вызываем функцию на связующем канале")
			// После создания bindCh и запуска горутины, вызывается текущая функция,
			// передавая в нее bindCh как входной канал. Возвращенный выходной канал
			// этой стадии становится новым outCh.
			return stage(bindCh) // Вызываем функцию из слайса с новым каналом
		}(outCh)
	}

	go func() {
		wg.Wait()
	}()

	// возвращается последний канал, который был сформирован после всех стадий.
	return outCh // Возвращаем последний выходной канал
}
